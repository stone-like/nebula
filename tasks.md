
### Part 1: LLMと対話する基盤を作る

#### Chapter 1: OpenAIと会話する最初のCLI
*   **この章のゴール:** GoからOpenAIのAPIを呼び出し、ターミナルで対話できる最小のプログラムを完成させる。
*   **タスク:**
    1.  Goのプロジェクトをセットアップする (`go mod init`)。
    2.  OpenAI APIクライアントライブラリを導入する。
    3.  APIキーを安全に環境変数から読み込む。
    4.  ユーザーからの入力を受け取り、Chat Completions APIに送信して応答を表示する。

#### Chapter 2: "Function Calling" でLLMの能力を拡張する
*   **この章のゴール:** LLMに「ツール」を使わせる方法を理解し、最初のツール`readFile`を実装する。
*   **タスク:**
    1.  Function Calling（Tool Calling）の概念を理解する。
    2.  `readFile`ツールのJSONスキーマをGoの構造体で定義する。
    3.  `readFile`の本体となる、指定されたファイルを読み込むGoの関数を実装する。
    4.  LLMからのツールコール要求を処理し、関数の結果をLLMに返す基本的な対話ループを構築する。

---

### Part 2: エージェントに手足を与える

#### Chapter 3: ファイルシステムを探索・創造するツール群
*   **この章のゴール:** エージェントが自身の周囲の状況を把握し、新しいファイルを作成できるようにする。
*   **タスク:**
    1.  `list`ツールを実装する（ファイル一覧の取得）。
    2.  `searchInDirectory`ツールを実装する（キーワード検索）。
    3.  `writeFile`ツールを実装する（新規ファイル作成）、ファイル作成時にユーザの許可をとること。
    4.  複数のツールを管理し、LLMが要求したツールを適切に呼び出す仕組みを構築する。

#### Chapter 4: 最重要機能 `editFile` と "Read-Modify-Write" パターン
*   **この章のゴール:** 既存ファイルを「安全」かつ「確実」に編集するための核心的なパターンを理解し、実装する。
*   **タスク:**
    1.  `editFile`ツールを実装する（ファイル全体の上書き）、ファイル編集時にユーザの許可をとること。
    2.  **理論編:** なぜ部分的な編集ツール（行番号指定など）が悪手なのかを解説する。
    3.  **実践編:** 「Read-Modify-Write」パターンを、エージェントの思考ログを追いながら具体例で詳細に解説する。
    4.  ツールスキーマの`Description`に、このパターンに従うよう指示を書き込む重要性を説明する。
    5.  **Tool Callingループの実装:** 複数ツールの連続呼び出しを可能にするループ処理を実装する。
    6.  **Read-Modify-Writeの動作確認:** editFileツールが自然にreadFile→editFileの順序で動作することを確認する。
    7.  **限界の体験:** システムプロンプトなしでは複雑な思考プロセスや複数ファイル編集で限界があることを体験し、次章への動機付けを行う。

---

### Part 3: エージェントに知性と個性を与える

#### Chapter 5: プロンプト設計：エージェントの「魂」を作る ✅ **完了**
*   **この章のゴール:** システムプロンプトを設計し、エージェントに一貫した役割と行動規範を与える。
*   **Chapter 4からの課題:** 最小限システムプロンプトでは複数ファイル編集や複雑な思考が必要なタスクで限界があることを受けて。
*   **完了したタスク:**
    1.  ✅ Chapter 4の限界体験を振り返り、なぜ本格的システムプロンプトが必要かを理解する。
    2.  ✅ システムプロンプトの重要性と構成要素（役割、制約、思考プロセス）を学ぶ。
    3.  ✅ `nebula`の思考プロセス（思考→計画→探索→実装）を定義したGemini CLI-inspiredシステムプロンプトを作成する。
    4.  ✅ 「ファイル編集の厳格なルール」をプロンプトに明記する。
    5.  ✅ **モデル選択機能の実装**: GPT-4.1-nano/miniの対話的切り替え機能
    6.  ✅ **設定管理システムの実装**: ~/.nebula/config.json による永続的な設定保存
    7.  ✅ **JSON処理の安全性強化**: 制御文字除去による安全なファイル操作
    8.  ✅ **複数ファイル編集テスト**: Clean Architecture todo-appでの実践テスト完了

#### Chapter 6: 最終機能の実装と完成
*   **この章のゴール:** nebulaの最終機能を実装し、実用的なコーディングエージェントとして完成させる。
*   **Chapter 5からの課題:** 現在のnebulaは基本的な複数ファイル編集能力を持つが、実用性と安全性の面でさらなる改善が必要。
*   **タスク:**
    1.  **SQLite依存関係の追加**: `modernc.org/sqlite`をgo.modに追加
    2.  **永続記憶パッケージの作成**: `memory/`パッケージの実装
        - `manager.go`: MemoryManager本体とAPI
        - `models.go`: Session, Message構造体定義
        - `database.go`: SQLite接続と初期化
        - `queries.go`: SQL操作関数群
    3.  **データベーススキーマの実装**: sessions + messagesテーブルの作成
    4.  **main.goとの統合**: セッション管理とメッセージ保存機能の統合
    5.  **プロジェクト固有記憶**: ディレクトリベースのセッション管理
    6.  **planモードの実装**: 読み取り専用モードと計画確認機能
    7.  **設定ファイル拡張**: config.jsonにメモリ設定を追加
    8.  **テストと最終調整**: 動作確認と仕上げ

---

### Part 4: 実践と未来

#### Chapter 7: 実践：`nebula`の活用と応用
*   **この章のゴール:** 完成した`nebula`を使い、実際のプロジェクトに対して自律的なコード編集を行わせる体験をする。
*   **タスク:**
    1.  演習用のサンプルプロジェクトでの実践
    2.  複雑な機能追加タスクの検証
    3.  モデル選択機能を活用した効率的な開発体験

#### おわりに：`nebula`とあなたの次のステップ
*   本書で作成した`nebula`の能力と特徴
*   今後の拡張アイデアの紹介：
    *   より高度なメモリ機能（ベクトルDB）
    *   危険だが強力なツール（`execute_command`によるテスト実行）
    *   コスト効率の良い編集方法（ブロック単位編集）への挑戦
*   自作エージェント開発の楽しさと、その先の未来について