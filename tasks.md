
### Part 1: LLMと対話する基盤を作る

#### Chapter 1: OpenAIと会話する最初のCLI
*   **この章のゴール:** GoからOpenAIのAPIを呼び出し、ターミナルで対話できる最小のプログラムを完成させる。
*   **タスク:**
    1.  Goのプロジェクトをセットアップする (`go mod init`)。
    2.  OpenAI APIクライアントライブラリを導入する。
    3.  APIキーを安全に環境変数から読み込む。
    4.  ユーザーからの入力を受け取り、Chat Completions APIに送信して応答を表示する。

#### Chapter 2: "Function Calling" でLLMの能力を拡張する
*   **この章のゴール:** LLMに「ツール」を使わせる方法を理解し、最初のツール`readFile`を実装する。
*   **タスク:**
    1.  Function Calling（Tool Calling）の概念を理解する。
    2.  `readFile`ツールのJSONスキーマをGoの構造体で定義する。
    3.  `readFile`の本体となる、指定されたファイルを読み込むGoの関数を実装する。
    4.  LLMからのツールコール要求を処理し、関数の結果をLLMに返す基本的な対話ループを構築する。

---

### Part 2: エージェントに手足を与える

#### Chapter 3: ファイルシステムを探索・創造するツール群
*   **この章のゴール:** エージェントが自身の周囲の状況を把握し、新しいファイルを作成できるようにする。
*   **タスク:**
    1.  `list`ツールを実装する（ファイル一覧の取得）。
    2.  `searchInDirectory`ツールを実装する（キーワード検索）。
    3.  `writeFile`ツールを実装する（新規ファイル作成）、ファイル作成時にユーザの許可をとること。
    4.  複数のツールを管理し、LLMが要求したツールを適切に呼び出す仕組みを構築する。

#### Chapter 4: 最重要機能 `editFile` と "Read-Modify-Write" パターン
*   **この章のゴール:** 既存ファイルを「安全」かつ「確実」に編集するための核心的なパターンを理解し、実装する。
*   **タスク:**
    1.  `editFile`ツールを実装する（ファイル全体の上書き）、ファイル編集時にユーザの許可をとること。
    2.  **理論編:** なぜ部分的な編集ツール（行番号指定など）が悪手なのかを解説する。
    3.  **実践編:** 「Read-Modify-Write」パターンを、エージェントの思考ログを追いながら具体例で詳細に解説する。
    4.  ツールスキーマの`Description`に、このパターンに従うよう指示を書き込む重要性を説明する。

---

### Part 3: エージェントに知性と個性を与える

#### Chapter 5: プロンプト設計：エージェントの「魂」を作る
*   **この章のゴール:** システムプロンプトを設計し、エージェントに一貫した役割と行動規範を与える。
*   **タスク:**
    1.  システムプロンプトの重要性と構成要素（役割、制約、思考プロセス）を学ぶ。
    2.  `nebula`の思考プロセス（思考→計画→探索→実装）を定義したシステムプロンプトを作成する。
    3.  「ファイル編集の厳格なルール」をプロンプトに明記する。

#### Chapter 6: `init`機能：プロジェクトを自己分析する能力
*   **この章のゴール:** `nebula init`コマンドを実装し、エージェントがプロジェクトの概要を自動で把握・要約できるようにする。
*   **タスク:**
    1.  Goでコマンドライン引数（`init`, `agent`など）を扱えるようにする。
    2.  `init`プロセスの実装：Goプログラムがファイル構造をスキャンし、主要ファイルを読み込む。
    3.  LLMに収集したデータを渡し、`NEBULA.md`を生成させるための`init`用プロンプトを実装する。
    4.  **理論編:** なぜこの処理をLLMに探索させず、Goプログラムが主導するのかを解説する。

#### Chapter 7: 最終組み立て：`agent`モードと動的コンテキスト
*   **この章のゴール:** これまで作ってきた部品をすべて組み合わせ、自律的に動作する`agent`モードを完成させる。
*   **タスク:**
    1.  `agent`モードの起動ロジックを実装する。
    2.  `NEBULA.md`が存在しない場合に、内部的に`init`プロセスを呼び出す処理を実装する。
    3.  `NEBULA.md`の内容（または内部`init`の結果）を、システムプロンプトに動的に埋め込む。
    4.  `plan`モードを実装する（書き込み系ツールを呼び出さないように制限する）。

---

### Part 4: 実践と未来

#### Chapter 8: 実践：`nebula`、初めての機能追加
*   **この章のゴール:** 完成した`nebula`を使い、実際のプロジェクトに対して自律的なコード編集を行わせる体験をする。
*   **タスク:**
    1.  演習用の簡単なサンプルプロジェクトを用意する（例: GoのシンプルなWebサーバー）。
    2.  `nebula init`を実行し、`NEBULA.md`が生成されることを確認する。
    3.  `nebula agent`に「`/health`エンドポイントを追加して」のような具体的な指示を与える。
    4.  成功（または失敗）するまでのエージェントの思考ログを追い、その挙動を分析する。

#### おわりに：`nebula`とあなたの次のステップ
*   本書で作成した`nebula`の限界と、さらなる発展の可能性。
*   今後の拡張アイデアの紹介：
    *   より高度なメモリ機能（ベクトルDB）。
    *   危険だが強力なツール（`execute_command`によるテスト実行）。
    *   コスト効率の良い編集方法（ブロック単位編集）への挑戦。
*   自作エージェント開発の楽しさと、その先の未来について。